---
title: 软件安全期末复习知识点（串讲转录 + 讲义PDF）
date: 2025-12-25 01:02:35
categories:
  - 学习资料
tags:
  - 期末
  - 笔记
  - 软件安全
slug: software-security-final-review
---

# 软件安全期末复习知识点（串讲转录 + 讲义PDF）

整理目标：把串讲转录中提到的“重点/必考点/题型”，与课程PDF讲义中的对应知识点合并成一份可直接复习的知识点文档，并在每个知识点旁标注可对照的PDF页码出处。

---

## 0. 考试题型与必考点导航

### 0.1 题型/分值（以转录为准）

- 【题型】填空题：10题×1分=10分。 【转录：record.md 00:00:26】
- 【题型】单选题：20题×1分=20分（累计30分）。 【转录：record.md 00:00:26】
- 【题型】简答题：5题×6分=30分（累计60分）。 【转录：record.md 00:00:26】
- 【题型】代码题：剩余分值来自代码题（转录描述为“看看一道两道…4道1~10分的样子”，以老师最终出卷为准）。 【转录：record.md 00:00:26】

### 0.2 串讲明确点名的“重点/必考点/可能出题点”（务必优先掌握）

- 【必考】【代码题】异常处理：会考1个代码题方向（围绕异常处理/SEH）。 【转录：record.md 00:10:26】
- 【必考】【代码题】堆溢出：会考2个代码题方向（围绕堆溢出/堆利用）。 【转录：record.md 00:10:26】
- 【必考】【代码题】SQL注入：必有一个SQL注入相关代码题。 【转录：record.md 00:10:26】
- 【重点】XSS分类：反射型/存储型要分清含义、触发方式与危害。 【转录：record.md 00:10:26】；【出处：第11讲.pdf p.68】【出处：第11讲.pdf p.69】【出处：第11讲.pdf p.70】
- 【重点】威胁建模：概念、目的、流程；STRIDE / DREAD / 数据流图（DFD）。 【转录：record.md 00:01:18】；【出处：第4讲.pdf p.5】【出处：第4讲.pdf p.62】【出处：第4讲.pdf p.12】【出处：第4讲.pdf p.24】【出处：第4讲.pdf p.40】
- 【重点】栈与栈帧：函数调用/退出过程、返回地址、EBP/ESP/EIP等（用于解释溢出/异常/跳板）。 【转录：record.md 00:05:19】；【出处：第13讲.pdf p.10】【出处：第9讲.pdf p.13】
- 【重点】Windows内存防护：GS、安全SEH校验（SafeSEH/SEHOP）、Safe Unlink、Lookaside等：原理与绕过思路。 【转录：record.md 00:08:32】；【出处：第13讲.pdf p.6】【出处：第14讲.pdf p.4】【出处：第15讲.pdf p.5】【出处：第15讲.pdf p.34】

---

## 1. 软件安全过程：SDL安全开发周期 + 七触点

### 1.1 SDL（Security Development Lifecycle）的定义、背景与适用范围

- SDL定义：微软提出的、从安全角度指导软件开发过程的管理模式。 【出处：第2讲.pdf p.52】
- SDL背景（为什么需要SDL）：从单用户系统到互联网时代，漏洞与安全需求增强，微软形成强制性SDL要求，要求产品符合SDL正式定义。 【出处：第2讲.pdf p.53】
- SDL适用软件范围（讲义给出的三类标准）：企业/政府广泛应用；广泛处理个人或敏感信息；广泛接入互联网的软件等。 【出处：第2讲.pdf p.54】
- SDL模型阶段：设计、开发、测试、发行和维护阶段（在传统开发过程上增加安全责任制与结构性）。 【出处：第2讲.pdf p.55】

### 1.2 SDL中的关键观念（常见简答/选择点）

- 安全教育（持续更新）：安全威胁不断变化，必须规划不断更新的培训，让开发者了解最新安全问题及缓和方法。 【出处：第2讲.pdf p.57】
- “安全是一种特性”：像其他产品特性一样，应设计到应用程序每个方面；不要把安全当作后期补救。 【出处：第2讲.pdf p.63】【出处：第2讲.pdf p.64】
- “尽早引入安全”：在设计阶段修复bug的成本远低于开发/测试阶段；要尽早确定安全目标并正确设计。 【出处：第2讲.pdf p.60】
- “用足够时间考虑安全”：安全影响成本与进度，越晚越贵；后期修复不是发行安全软件的方法。 【出处：第2讲.pdf p.66】
- “安全的设计源于威胁建模”：没有威胁模型就难以创建安全系统，需要为威胁建模预留时间。 【出处：第2讲.pdf p.67】

### 1.3 七触点（Cigital Touchpoints）安全开发过程

讲义给出的“软件安全实施方法/七触点”清单（建议能写出中文名，并能解释每个触点在开发周期中的位置与作用）：
- 误用用例（Misuse Cases）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.79】
- 安全需求（Security Requirements）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.79】
- 架构风险分析（Architecture Risk Analysis）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.80】
- 代码审查（Code Review）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.81】
- 基于风险的安全测试（Risk-Based Security Testing）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.80】
- 渗透性测试（Penetration Testing）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.81】
- 安全操作（Security Operations）。 【出处：第2讲.pdf p.78】【出处：第2讲.pdf p.82】

---

## 2. 威胁建模（Threat Modeling）：概念、DFD、STRIDE、DREAD、威胁树

### 2.1 核心概念与目的（定义题/简答题高频点）

- 基本观点：直到理解了所受的威胁之后才能创建安全的系统。 【出处：第4讲.pdf p.4】
- 威胁模型的定义与目标：一种基于安全的分析，帮助确定产品造成的最高安全风险以及攻击如何表现；目标是确定需要缓和哪些威胁、如何缓和。 【出处：第4讲.pdf p.5】
- 额外作用（常用于“为什么要做威胁建模”的简答）：帮助理解应用组成与交互、辅助测试查bug、发现复杂组合bug、帮助新成员理解系统、支持安全测试计划等。 【出处：第4讲.pdf p.6】

### 2.2 建模组织方式：成立小组 + 形式化分解

- 成立威胁建模小组：设计/编程/测试/文档等至少各1人参加；会议目标是识别应用组成、交互方式、尽可能多的安全威胁（不是当场解决方案）。 【出处：第4讲.pdf p.9】
- 需要结构化方法：威胁建模不是简单“想象威胁”，要形式化分解。 【出处：第4讲.pdf p.11】

### 2.3 DFD（Data Flow Diagram）数据流图：用途、定义、符号

- DFD作用：将应用程序分解为关键部分，用于威胁分解的形式化技术；UML活动图偏控制流，DFD偏数据流。 【出处：第4讲.pdf p.11】
- DFD定义：描述信息系统逻辑模型，综合反映信息在系统中的流动、处理、存储情况。 【出处：第4讲.pdf p.12】
- DFD关键符号（至少能说清“表示什么”）：过程/数据存储/边界（信任边界等）/交互者/数据流等。 【出处：第4讲.pdf p.13】
- 分解深度经验：一般深入到2~4级，原则是“深入到足够理解所受威胁为止”。 【出处：第4讲.pdf p.20】

### 2.4 STRIDE：威胁分类（重点背“六类+含义+例子”）

STRIDE是六类威胁英文首字母缩写： 【出处：第4讲.pdf p.24】
- S 身份欺骗（Spoofing identity）：冒充用户/服务器（如DNS欺骗、DNS缓存中毒等）。 【出处：第4讲.pdf p.25】
- T 篡改数据（Tampering with data）：未授权修改数据库/传输数据/弱ACL保护文件等。 【出处：第4讲.pdf p.26】
- R 抵赖（Repudiation）：用户否认做过某事；需要防抵赖能力（Nonrepudiation）。 【出处：第4讲.pdf p.27】
- I 信息泄露（Information disclosure）：信息暴露给不允许访问的人（读文件/嗅探传输数据等）。 【出处：第4讲.pdf p.28】
- D 拒绝服务（Denial of service）：拒绝合法用户服务（如DDoS）。 【出处：第4讲.pdf p.29】
- E 特权提升（Elevation of privilege）：低权限获得高权限，成为受信任系统的一部分等。 【出处：第4讲.pdf p.30】

### 2.5 威胁树（Threat Tree）：用途与读法

- 威胁树：系统地分析应用的威胁与漏洞；类似“故障树”。描述攻击者破坏组件的决策过程。 【出处：第4讲.pdf p.31】
- 示例：以“在线浏览秘密工资表数据”为目标，分解为通信不受保护、嗅探/监听/破坏设备等路径。 【出处：第4讲.pdf p.34】
- 可读性增强：标注更可能/更不可能攻击点，剪枝；对弱点原因做说明。 【出处：第4讲.pdf p.35】

### 2.6 DREAD：风险分级（重点背“5个维度+怎么算”）

- DREAD五维：Damage potential（潜在破坏性）、Reproducibility（再现性）、Exploitability（可利用性）、Affected users（影响用户）、Discoverability（可发现性）。 【出处：第4讲.pdf p.40】
- 评分方法示例：对五项打分取平均得到风险等级（示例中得到9，需尽快解决）。 【出处：第4讲.pdf p.46】

### 2.7 威胁建模完整流程（建议背成“可复述的5步法”）

- 流程总结：分解应用为威胁目标 → STRIDE标识威胁 → 威胁树分析如何成隐患 → DREAD分级 → 风险排序后进入缓和/修复。 【出处：第4讲.pdf p.62】【出处：第4讲.pdf p.93】
- 记录项目（建模产物应包含的信息）：标题、威胁目标、威胁类型、风险计算、攻击树、缓和技术、缓和状态、Bug数量等。 【出处：第4讲.pdf p.37】
- STRIDE到缓和方法示例（工资表范例）：如信息泄露用SSL/TLS或IPSec，拒绝服务用防火墙/限制资源等。 【出处：第4讲.pdf p.92】

---

## 3. 漏洞与利用基础：0day/1day、三步法、工具链

### 3.1 bug vs 漏洞（vulnerability）

- 漏洞定义：能引起软件做“超出设计范围的事情”的bug。功能性bug影响功能；安全性漏洞通常不影响正常功能但可被利用执行恶意代码。 【出处：第5讲.pdf p.4】
- 常见漏洞例子（讲义举例）：缓冲区溢出、XSS、SQL注入等。 【出处：第5讲.pdf p.4】

### 3.2 漏洞利用的三步法（串讲明确点名）

- 三步法：漏洞挖掘 → 漏洞分析 → 漏洞利用。 【转录：record.md 00:02:56】；【出处：第5讲.pdf p.5】【出处：第5讲.pdf p.6】【出处：第5讲.pdf p.7】
- 漏洞挖掘：学术界常静态分析；工程界常用Fuzz等。 【出处：第5讲.pdf p.5】
- 漏洞分析：调试二进制、利用POC重现；无POC可做补丁对比后逆向关键修改处。 【出处：第5讲.pdf p.6】

### 3.3 0day / 1day（考试常见概念题）

- 0day：未公布、未修复且可被攻击者利用的漏洞；危害最大，补丁发布前处于高危预警。 【出处：第5讲.pdf p.8】；（串讲也点名）【转录：record.md 00:02:56】
- 1day：补丁发布后攻击者研究补丁、在用户未及时修复窗口期利用的新公布漏洞。 【出处：第5讲.pdf p.9】

### 3.4 漏洞分析/利用常用工具（至少能写出“工具—用途”）

- OllyDbg：集反汇编、十六进制编辑、动态调试于一体，常用于无源码PE调试实验。 【出处：第5讲.pdf p.23】
- IDA Pro：静态反汇编/逆向分析（讲义在Crack实验中示范先用IDA定位分支，再用OllyDbg动态确认）。 【出处：第5讲.pdf p.41】【出处：第5讲.pdf p.44】
- Visual Studio调试：查看窗口/注释反汇编/内存窗口/跳转到定义等，便于定位问题。 【出处：第5讲.pdf p.32】【出处：第5讲.pdf p.33】【出处：第5讲.pdf p.34】【出处：第5讲.pdf p.35】
- 二进制编辑器：UltraEdit/WinHex等，用于修改二进制字节（Crack中需要把内存修改同步到文件）。 【出处：第5讲.pdf p.36】【出处：第5讲.pdf p.48】
- （转录提到但讲义未直接展开）Kali/Metasploit等漏洞测试平台与工具：建议至少知道Metasploit是常用漏洞利用框架/测试平台。 【转录：record.md 00:03:57】

---

## 4. 二进制与虚拟内存基础：PE节、VA/RVA、地址换算

> 这一部分通常用于解释“代码区/数据区/堆/栈”，以及理解调试器里的地址、溢出覆盖的对象与位置。

### 4.1 PE文件格式与常见节（.text/.data/.idata/.rsrc）

- PE（Portable Executable）：Win32下可执行文件数据格式；不仅包含机器码，也包含字符串/菜单/图标等资源；装载时按约定定位并装入内存不同区域。 【出处：第5讲.pdf p.11】
- PE按节（section）组织资源：典型节包括 `.text`（机器码/反汇编对象）、`.data`（初始化数据/全局静态等）、`.idata`（导入库/外来函数信息）、`.rsrc`（资源）等。 【出处：第5讲.pdf p.12】

### 4.2 Windows虚拟内存：为什么调试器看到的是“虚拟地址”

- 用户态看到的是虚拟内存地址；Windows让进程“相信”自己拥有独立4GB空间，实际通过虚拟内存管理器映射到物理内存。 【出处：第5讲.pdf p.13】
- 类比：进程=储户，内存管理器=银行，虚拟内存=存款，物理内存=现金。 【出处：第5讲.pdf p.15】

### 4.3 文件偏移/装载基址/VA/RVA：四个概念与关键公式

讲义定义： 【出处：第5讲.pdf p.17】
- File Offset：数据在磁盘文件中相对文件开头的偏移。
- Image Base：PE装入内存的基地址（EXE常见0x00400000，DLL常见0x10000000，可改）。
- VA（Virtual Address）：指令/数据装入内存后的虚拟地址。
- RVA（Relative Virtual Address）：相对装载基址的偏移。

关键关系式：
- `VA = Image Base + RVA`。 【出处：第5讲.pdf p.17】

### 4.4 文件偏移与VA换算（做题/实验常考“怎么算”）

- PE按0x200字节对齐组织；内存按0x1000字节页对齐组织；两者差异导致“节偏移”。 【出处：第5讲.pdf p.19】【出处：第5讲.pdf p.20】
- 讲义给出的换算形式：`文件偏移 = VA - ImageBase - 节偏移 = RVA - 节偏移`（并给出示例）。 【出处：第5讲.pdf p.21】

### 4.5 x86栈帧与关键寄存器速记（ESP/EBP/EIP）

> 串讲要求“至少知道ESP/EBP/EIP分别干什么”，并要求能说清“函数调用/退出、返回地址、栈帧建立”。【转录：record.md 00:01:18】【转录：record.md 00:05:19】

以下为x86（32位）下最常见的栈帧/寄存器理解框架（用于解释栈溢出、SEH、GS、跳板等）：
- ESP（Stack Pointer，栈顶指针）：指向当前栈顶；`push`会减小ESP、`pop`会增大ESP（栈向低地址增长是常见实现）。【转录：record.md 00:01:18】
- EBP（Base Pointer/Frame Pointer，栈帧基址指针）：常用来“固定”当前函数栈帧的参考点，便于用`[ebp±offset]`访问参数/局部变量；也常出现在异常链、cookie计算等机制中。 【转录：record.md 00:01:18】；（GS中提到cookie与EBP异或）【出处：第13讲.pdf p.18】
- EIP（Instruction Pointer，指令指针）：指向下一条将要执行的指令；“控制流劫持”的本质通常就是让EIP跳到攻击者想去的地址（如shellcode/ROP）。【转录：record.md 00:01:18】

典型函数调用与栈帧建立（概念顺序题常考）：
- 调用前：调用者把参数按约定压栈（或通过寄存器传参，取决于调用约定）。【转录：record.md 00:05:19】
- `call target`：CPU把“返回地址”压栈，然后跳转到被调函数入口（返回地址用于`ret`回到调用点之后）。【转录：record.md 00:05:19】
- 被调函数序言（常见形式）：`push ebp; mov ebp, esp; sub esp, N` ——保存旧EBP、建立新栈帧、为局部变量预留空间。 【转录：record.md 00:05:19】
- 被调函数退出（常见形式）：`mov esp, ebp; pop ebp; ret` ——恢复栈帧并弹出返回地址到EIP。 【转录：record.md 00:05:19】

与本课程考点的对应关系（把“抽象概念”落到题目上）：
- SEH在栈中，且经常位于EBP/返回地址附近，因此溢出时可能覆盖SEH链表指针/回调句柄。 【出处：第9讲.pdf p.13】
- GS在返回地址前布置Security Cookie，并在返回前进行校验；cookie生成与EBP有关。 【出处：第13讲.pdf p.10】【出处：第13讲.pdf p.18】

---

## 5. 堆与栈：基本原理、数据结构、典型利用与防护

### 5.1 堆 vs 栈（概念题/简答题常考）

- 栈内存：函数栈帧中为局部变量预留空间；由系统维护，分配/回收由系统完成，最终保持栈平衡。 【出处：第8讲.pdf p.7】
- 堆内存：运行时动态分配（malloc/HeapAlloc等），大小无法预先决定；由程序员申请/使用/释放，否则可能泄漏。 【出处：第8讲.pdf p.7】
- 对比：栈“线性、整齐”，利用相对容易；堆“杂乱”，堆溢出利用是内存利用技术转折点。 【出处：第8讲.pdf p.8】

### 5.2 Windows堆的两类核心数据结构：堆表 + 堆块（必背）

- 现代堆结构：包括“堆表”和“堆块”两类。 【出处：第8讲.pdf p.11】
- 堆表：位于堆区起始位置，用于索引堆块位置/大小/空闲或占用等；可能不止一种数据结构。 【出处：第8讲.pdf p.11】
- 堆块（chunk）：按块管理（非按字节）；由块首（header，记录大小/状态等）+ 块身（body，返回给用户的数据区）组成。 【出处：第8讲.pdf p.11】

### 5.3 堆表组成与两种“表”：Freelist（空表）与 Lookaside（快表）

- 识别堆表时提到：heap_vis插件不易区分freelist与lookaside两种堆表（说明这两者是重要结构）。 【出处：第8讲.pdf p.34】
- 堆区起始处的典型布局（调试“整齐堆”时可观察）：段表索引（Segment List）、虚表索引（Virtual Allocation list）、空表使用标识（freelist usage bitmap）、空表索引区等。 【出处：第8讲.pdf p.36】
- 初始化时典型状态：只有一个空闲大块“尾块”；`Freelist[0]`指向尾块；其余空表索引指向自身表示为空。 【出处：第8讲.pdf p.38】【出处：第8讲.pdf p.39】

### 5.4 堆块块首（header）关键字段理解

- 讲义给出“占用态/空闲态堆块数据结构”示意。 【出处：第8讲.pdf p.40】【出处：第8讲.pdf p.41】
- 讲义强调：调试器里常看到的“堆块指针”会跳过块首8字节，直接指向数据区；堆块大小包含块首。 【出处：第8讲.pdf p.44】

### 5.5 【必考】【代码题】堆溢出利用方向1：DWORD SHOOT（双向链表卸载写入）

这一部分强烈建议按讲义思路把“堆块状态→释放→再次申请→卸载链表→发生写入”的因果链讲清楚（简答/代码题都可能用到）。

- 释放后空表（freelist）中会链接空闲堆块；再次申请会从对应空表取块并将节点从双向链表“卸下”。 【出处：第8讲.pdf p.72】
- 若在卸下前篡改空闲块中的前向/后向指针，则卸载过程会产生写入（DWORD SHOOT）；示例：把前向指针改成0x44444444、后向指针改成0x00000000会导致写入并触发异常。 【出处：第8讲.pdf p.76】
- DWORD SHOOT用于代码植入/劫持：讲义示例把目标定为PEB中的函数指针，使ExitProcess清理现场时调用到shellcode。 【出处：第8讲.pdf p.86】
- 溢出覆盖尾块块首、构造“子弹/目标”布局的要点：后向指针可设为P.E.B中函数指针地址0x7FFDF020，前向指针设为shellcode起始地址等。 【出处：第8讲.pdf p.88】
- 注意事项：堆地址不固定，需要“定位shellcode的跳板”思路；以及DWORD SHOOT可能出现“指针反射”破坏shellcode的4字节。 【出处：第8讲.pdf p.94】

### 5.6 堆溢出利用方向2：利用SEH/UEF/PEB等作为目标（与异常处理联动）

- 堆溢出常伴随异常；因此SEH是DWORD SHOOT常选目标之一：把SEH异常回调句柄作为写入目标，替换为shellcode入口，异常发生后执行shellcode。 【出处：第9讲.pdf p.15】【出处：第9讲.pdf p.16】【出处：第9讲.pdf p.17】
- 攻击U.E.F（系统默认异常处理）：若能覆盖其调用句柄为shellcode入口，再制造无法被其他处理解决的异常，即可执行shellcode；并提到可结合“跳板技术”提高成功率。 【出处：第9讲.pdf p.30】
- 攻击PEB中的函数指针：ExitProcess结束进程时需要进入临界区，会通过PEB中指针调用`RtlEnterCriticalSection`/`RtlLeaveCriticalSection`等；DWORD SHOOT可把这些指针改为shellcode入口。 【出处：第9讲.pdf p.32】【出处：第8讲.pdf p.86】

### 5.7 堆保护机制（Windows XP SP2以后）与绕过思路

讲义总结的堆保护机制（建议能写出名字+保护点）：
- PEB random（ASLR影响PEB基址）：不再固定0x7ffdf000，随机化主要增加攻击PEB函数指针难度。 【出处：第15讲.pdf p.4】
- Safe Unlink：卸载freelist双向链表时提前验证前向/后向指针完整性，防止DWORD SHOOT。 【出处：第15讲.pdf p.5】
- heap cookie：堆中引入cookie检测堆溢出（布置在堆首部分segment table位置，占1字节）。 【出处：第15讲.pdf p.6】
- 元数据加密：Vista及后续对块首关键数据与随机数异或保存，使用时再异或还原，防止直接破坏元数据。 【出处：第15讲.pdf p.7】
- 研究者观点：PEB random随机区间有限；heap cookie仅1字节仍可能被破解；Safe Unlink等也存在破解思路，但总体利用更苛刻。 【出处：第15讲.pdf p.8】

#### 5.7.1 【重点】Safe Unlink的“验证点”与一个典型绕过方向（重设chunk大小）

- Safe Unlink核心：从`FreeList[n]`拆卸chunk时验证双向链表有效性。 【出处：第15讲.pdf p.10】
- 讲义指出一个利用思路：插入到`FreeList[n]`时是否校验？若伪造chunk并插入链表，可能造成攻击；插入发生在释放重新入链、或切分产生新chunk入链。 【出处：第15讲.pdf p.10】
- 讲义指出缺陷/机会：即便检测到chunk结构被破坏，仍允许后续一些操作执行，例如“重设chunk大小”。 【出处：第15讲.pdf p.12】

#### 5.7.2 【必考】【代码题】Lookaside（快表）单链表：利用“无验证”做堆溢出

- 关键点：Safe Unlink保护的是空表（freelist）双向链表；而快表（lookaside）是单链表，拆卸时没有做同等验证，可被利用。 【出处：第15讲.pdf p.34】
- 若控制`node->next`就控制`Lookaside[n]->next`；当再次申请时系统会把伪造地址当作返回给用户的堆块起始地址，形成“把写入引到任意地址”的机会。 【出处：第15讲.pdf p.35】
- 讲义实验思路：先申请/释放多个16字节块进入快表；溢出覆盖下一块的“下一堆块指针”；使后续申请返回伪造地址；把该地址设置为异常处理函数指针位置并触发除0异常以劫持流程。 【出处：第15讲.pdf p.38】【出处：第15讲.pdf p.46】

---

## 6. 异常处理机制（SEH）与 SafeSEH：结构、利用、校验与绕过

### 6.1 SEH基本概念与数据结构（必背“两个DWORD”）

- Windows异常处理机制：系统提供补救机会处理错误，以保证健壮稳定运行。 【出处：第9讲.pdf p.4】
- S.E.H（异常处理结构体）数据结构：每个S.E.H包含两个DWORD指针（共8字节）——链表指针 + 异常处理函数句柄。 【出处：第9讲.pdf p.4】（串讲也反复强调）【转录：record.md 00:08:32】
- SEH要点（建议能写出“在哪里、怎么串、怎么找”）：SEH结构体在系统栈中；线程初始化自动安装；`_try/_except`等会安装；栈中可有多个SEH；通过链表指针从栈顶向栈底串成单向链表，链头由TEB 0偏移指针标识等。 【出处：第9讲.pdf p.5】
- 异常发生时的处理：从TEB取最近SEH，失败则沿链表尝试；都失败则进程异常处理/系统默认异常处理。 【出处：第9讲.pdf p.6】

### 6.2 SEH利用基本思路（栈溢出/堆溢出中都可能出现）

- 基本思路：SEH在栈内，溢出可能淹没SEH；精心构造可把异常处理函数入口改为shellcode入口；溢出后错误状态常触发异常；系统处理异常时把shellcode当异常处理函数执行。 【出处：第9讲.pdf p.8】
- 栈溢出利用示例：在`_try`中制造除0异常；若`strcpy`溢出精确覆盖SEH回调句柄为shellcode入口，则异常处理时执行shellcode。 【出处：第9讲.pdf p.10】

### 6.3 SafeSEH：保护原理与校验流程（高频选择/简答）

- SafeSEH引入：Windows XP SP2及后续版本引入SEH校验机制SafeSEH。 【出处：第14讲.pdf p.4】
- SafeSEH基本原理：在调用异常处理函数前进行有效性校验；发现不可靠则终止调用；需要“操作系统+编译器”双重支持。 【出处：第14讲.pdf p.4】
- 编译器侧：启用`/SafeSEH`链接选项；把所有异常处理函数地址提取并写入安全SEH表（SafeSEH Table），调用时进行匹配；可用`dumpbin /loadconfig`查看。 【出处：第14讲.pdf p.5】
- 操作系统侧校验（在RtlDispatchException开始）：(1)异常处理链是否在当前栈中；(2)异常处理函数指针是否指向当前栈；(3)调用`RtlIsValidHandler`做进一步验证。 【出处：第14讲.pdf p.8】
- `RtlIsValidHandler`关键检查点（按讲义顺序）：NO_SEH标识、是否有安全SEH表并匹配、ILonly标识、DEP相关检查、是否允许跳出加载模块地址空间等。 【出处：第14讲.pdf p.11】【出处：第14讲.pdf p.12】

### 6.4 SafeSEH绕过思路（串讲强调“范围内/范围外”）

串讲提到SafeSEH的绕过方法与“某个范围之内/范围之外”思想（讲义对应为“模块内/模块外地址”等绕过路径）。【转录：record.md 00:08:32】

- 使用未启用SafeSEH的模块绕过：若加载模块未启用SafeSEH且非仅IL，可在模块中找指令做跳板（如`pop pop retn`）。 【出处：第14讲.pdf p.24】【出处：第14讲.pdf p.28】
- 利用加载模块之外地址绕过：在整个进程空间搜索可用跳板（不只在加载模块内）；示例使用`call/jmp dword ptr [ebp+n]`类指令作为跳板。 【出处：第14讲.pdf p.48】
- 链式跳转细节（理解为何与EBP/栈帧有关）：讲义用SEH chain解释“顺着链表找下一个handler”的本质可视为函数栈帧切换；并示例通过短跳转+长跳转两次回跳到shellcode。 【出处：第14讲.pdf p.52】【出处：第14讲.pdf p.56】【出处：第14讲.pdf p.58】

---

## 7. GS与Windows内存保护机制：能防什么、不能防什么

### 7.1 Windows内存保护机制概述（考点汇总）

讲义列出的典型内存保护增强点（建议能逐条解释其保护对象）：
- GS：在返回地址前加入Security Cookie。 【出处：第13讲.pdf p.6】
- S.E.H安全校验机制：挫败多数通过改写SEH劫持进程的攻击（SafeSEH/系统级SEHOP等）。 【出处：第13讲.pdf p.6】
- 堆保护：Heap Cookie、Safe Unlinking等。 【出处：第13讲.pdf p.6】
- DEP：数据执行保护，把数据部分标示为不可执行。 【出处：第13讲.pdf p.6】
- ASLR：加载地址随机，使经典堆栈溢出手段失效。 【出处：第13讲.pdf p.6】
- SEHOP：把SEH保护提升到系统级别。 【出处：第13讲.pdf p.6】

### 7.2 GS保护原理（Security Cookie / Canary）

- GS目的：针对缓冲区溢出覆盖返回地址这一特征。 【出处：第13讲.pdf p.9】
- 栈帧中额外数据：函数调用时在栈帧压入随机DWORD（canary/Security Cookie）；Cookie位于EBP之前；`.data`区域还存放一个Cookie副本。 【出处：第13讲.pdf p.10】
- 返回前检查：比较栈帧Cookie与`.data`副本，不一致则认为栈溢出发生，进入异常处理流程，不执行正常`ret`。 【出处：第13讲.pdf p.11】
- 不是所有函数都默认应用GS（性能权衡）：不含缓冲区、变参函数、无保护关键字、首语句含内联汇编、缓冲区太小等情形可能不受保护；可用`#pragma strict_gs_check(on)`强制启用。 【出处：第13讲.pdf p.13】【出处：第13讲.pdf p.14】

### 7.3 GS能防/不能防（串讲要求“哪些能防、哪些不能防”）

- 讲义对GS效果的总结（建议原话级别掌握）：覆盖返回地址的经典攻击会被遏制；改写函数指针/异常处理机制/堆溢出等GS很难防御。 【出处：第13讲.pdf p.20】
- GS不是“万能”：讲义随后展示了多种突破方法（如利用未被GS保护的函数、覆盖虚函数等）。 【出处：第13讲.pdf p.22】【出处：第13讲.pdf p.24】

---

## 8. 其他内存攻击技术：虚函数攻击与堆喷射（Heap Spray）

### 8.1 攻击C++虚函数（Vtable/Vptr）

- 虚函数动态调用机制要点：虚函数入口地址统一保存在虚表（Vtable）；对象通过虚表指针找到虚表，再取函数入口地址调用；虚表指针在对象内存空间中，紧接着是成员变量等。 【出处：第9讲.pdf p.33】
- 利用局限性：虚表指针位于成员变量之前，溢出只能向后覆盖；在栈溢出场景有局限；若多个对象相邻或DWORD SHOOT场景，改虚表指针/虚函数指针是可选方案。 【出处：第9讲.pdf p.38】
- 与GS的关系：GS只在函数返回检查Cookie；若能在检查前通过虚函数调用劫持流程，可能绕过GS（讲义给出“覆盖虚函数突破GS”的动机说明）。 【出处：第13讲.pdf p.24】

### 8.2 Heap Spray（堆与栈协同）

- 场景：浏览器/ActiveX存在溢出漏洞时，最终拿到EIP；复杂内存环境下难直接布置完整shellcode；可用JavaScript申请堆内存把shellcode布置在堆中。 【出处：第9讲.pdf p.39】
- 基本思路：让EIP指向堆区某个固定模式地址（如0x0C0C0C0C），通过大量申请并用含NOP+shellcode的内存片覆盖堆；只要NOP命中该位置即可滑到shellcode。 【出处：第9讲.pdf p.40】【出处：第9讲.pdf p.42】

---

## 9. Web输入问题：SQL注入、XSS、Session/Cookie

> 串讲明确：SQL注入必出代码题；XSS分类是选择/填空重点；并提到“session欺骗/达到目的”。【转录：record.md 00:10:26】

### 9.1 【必考】【代码题】SQL注入：概念、判断、常见元字符、修复思路

#### 9.1.1 SQL注入概念与危害

- SQL注入定义：利用用户输入构造SQL语句；若验证不当可改变SQL结构；应用组件常高权限运行，攻击者可获得数据库完全控制甚至执行系统命令。 【出处：第10讲.pdf p.11】
- SQL注入广泛存在，属于Web应用开发漏洞而非数据库自身问题；讲义给出“超过60%应用存在”统计描述。 【出处：第10讲.pdf p.12】
- 应用层攻击不能单靠网络层防护（防火墙/SSL/IDS等）阻止。 【出处：第10讲.pdf p.13】

#### 9.1.2 注入的典型成因：字符串拼接SQL

- 典型危险写法：`"SELECT ... WHERE login = '" + formusr + "' AND password = '" + formpwd + "'"`。 【出处：第10讲.pdf p.15】
- 典型注入例：用户名输入`' or 1=1 --`导致条件恒真（并用注释截断后续条件）。 【出处：第10讲.pdf p.16】【出处：第10讲.pdf p.17】

#### 9.1.3 SQL注入“元字符/语法糖”速记（选择题高频）

- 讲义列举的常见SQL元字符/技巧：`'`/`"`、`--`/`#`注释、`/*...*/`多行注释、`+`连接/空格、`||`连接、`%`通配符、URL参数、`@variable`/`@@variable`、`waitfor delay`延时等。 【出处：第10讲.pdf p.20】

#### 9.1.4 【重点】SQL注入漏洞判断：1=1 / 1=2 测试法（串讲点名）

- 整型参数：原SQL形如 `select * from 表 where 字段=YY`；用`and 1=1`与`and 1=2`测试。 【出处：第10讲.pdf p.30】；（串讲点名“1=2测试法”）【转录：record.md 00:12:17】
- 讲义给出的“三步判断”现象对照：`YY and 1=2`异常、`YY'`异常、`YY and 1=1`正常则可判定存在注入。 【出处：第10讲.pdf p.31】
- 字符串参数：原SQL形如 `... where 字段='YY'`；用`YY' and '1'='2`等方式测试。 【出处：第10讲.pdf p.32】【出处：第10讲.pdf p.33】

#### 9.1.5 防御要点（能写成简答答案）

讲义总结的“简单规则”版防御要点（可直接背诵）：
- 不要相信用户输入；严格限制合法输入形式，拒绝其他形式（正则表达式）。 【出处：第10讲.pdf p.96】
- 使用参数化查询（parameterized command），不要用字符串拼接创建查询语句。 【出处：第10讲.pdf p.96】【出处：第10讲.pdf p.83】
- 最小特权账号连接数据库，避免sysadmin；限制扩展存储过程等高危能力。 【出处：第10讲.pdf p.82】【出处：第10讲.pdf p.96】
- 不向攻击者泄漏过多信息（错误回显/日志策略等）。 【出处：第10讲.pdf p.96】

补充：讲义专门强调“存储过程不是银弹”（可做判断题/简答的反例点）：
- 仅仅“改用存储过程”可能只能阻止某些攻击类型，但不保证免疫；不当写法仍可能被注入执行数据操作，甚至存在“执行任意语句”的危险存储过程。 【出处：第10讲.pdf p.80】【出处：第10讲.pdf p.81】【出处：第10讲.pdf p.89】

### 9.2 【重点】XSS：反射型 vs 存储型 vs DOM型，触发条件与危害

#### 9.2.1 XSS概念与危害

- XSS定义：恶意攻击者往Web页面插入恶意代码；用户浏览时执行；攻击通常以JavaScript段形式出现，也可能是HTML/Flash等。 【出处：第11讲.pdf p.22】【出处：第11讲.pdf p.63】
- 常见危害：窃取cookies/session信息、重定向到攻击者控制内容、假借站点对用户做恶意操作。 【出处：第11讲.pdf p.63】

#### 9.2.2 【必考】反射型XSS vs 存储型XSS（如何区分）

- 讲义总结：XSS可通过三种媒介进入受害者：反射型、存储型、应用外部数据源。 【出处：第11讲.pdf p.68】
- 对照表要点：恶意代码存放位置（地址栏 vs 数据库）；触发方式（点恶意链接即时触发 vs 浏览“正常页面”自动触发）；隐蔽性（反射低、存储高）。 【出处：第11讲.pdf p.69】
- 反射型XSS定义：诱使用户向有漏洞站点提交危险内容，站点反射给用户并执行；常见方式把恶意内容作为URL参数发送给受害者（钓鱼核心）。 【出处：第11讲.pdf p.70】
- 存储型XSS定义：恶意内容进入数据库等持久存储，成为内容渠道；间接性更隐蔽，影响用户更多。 【出处：第11讲.pdf p.66】【出处：第11讲.pdf p.83】
- DOM-based XSS：基于DOM树的节点遍历/修改；通过URL参数控制触发；讲义指出可视为反射型的一种（输出点在DOM）。 【出处：第11讲.pdf p.89】

#### 9.2.3 触发条件（可做选择/简答）

- 讲义给出的XSS触发条件四类：完整无错的脚本标记、访问文件的标记属性、触发事件、请求失败。 【出处：第11讲.pdf p.31】

#### 9.2.4 防御要点（输入验证 + 输出编码 + Cookie策略等）

- 开发者侧通用建议：对所有用户提交内容做可靠输入验证（URL/查询关键字/http头/post数据等）；保护敏感功能防止被第三方或bots执行；实现session tokens或HTTP引用头检查；必要时使用HttpOnly cookie等。 【出处：第11讲.pdf p.100】

### 9.3 Session/Cookie相关：为什么XSS常用于“会话欺骗/冒充”

- 讲义指出：XSS攻击经常传送私有数据（cookies或其他session信息）给攻击者。 【出处：第11讲.pdf p.63】
- 结合串讲提问点（“session欺骗攻击能达到什么目的”）：若攻击者获取/复用受害者的session标记（cookie/session token），通常可冒充受害者执行操作或访问受害者敏感数据（本质是身份冒充）。 【转录：record.md 00:10:26】；（XSS窃取session信息的证据见上）【出处：第11讲.pdf p.70】
- 传统安全技术不足处也提到“Session/cookie机制的不足”（说明仅靠传统网络层监控难覆盖应用层会话层威胁）。 【出处：第1讲.pdf p.70】

---

## 10. 串讲中出现但在现有PDF中未直接展开的点（以转录为准，复习时建议回看课堂笔记/额外PPT）

> 下列内容在`record.md`中被明确点名为考点/复习点，但在当前目录可见的`第X讲.pdf`文本中未检索到足够展开材料；此处仅做“复习清单化”整理，建议你配合课堂笔记或老师额外发的PPT复习。

- 【重点】格式化控制符漏洞：`%x` / `%p` / `%n` 的意义与在漏洞利用中的作用（可能出选择题）。 【转录：record.md 00:06:31】
- 【重点】跳板（Trampoline）的目的与缓冲区数据布置（如`jmp esp`/`pop pop ret`/多级跳转等思想）。 【转录：record.md 00:06:31】（SafeSEH绕过中的跳板示例可参考）【出处：第14讲.pdf p.28】【出处：第14讲.pdf p.56】
- 【重点】动态定位API（遍历DLL导出表、拼装绝对地址）的大概流程。 【转录：record.md 00:07:35】
- 【重点】汇编“编码/解码”关系：难点在解码，理解指令与机器码对应。 【转录：record.md 00:07:35】
- 【重点】漏洞测试平台/工具：Kali + Metasploit的定位与用途。 【转录：record.md 00:03:57】
- 【重点】“快照本攻击/后注入”等老师额外发PPT自学内容（转录提到）。 【转录：record.md 00:10:26】
